---

---



1. Mysql行锁和表锁的实现原理

2. Mysql分库分表

3. Flask的高并发http请求实现，多线程模型？

   可以看到flask 为我们提供了三种方式来处理请求 
   1 使用多线程来进行处理 
   2 使用多进程来进行处理 
   3 使用poll 或者 select IO多路复用的方式进行处理　　`BaseWSGIServer` 这个类是使用IO 多路复用的 

4. http请求的三次握手和四次挥手，2倍的等待时间原因

   为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝

5. [linux常用命令](./linux常用命令.md)

6. Nginx负载均衡算法，和多层负载均衡模型

7. IO复用

   select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间
   
8. Mysql锁

   ```mysql
   行锁：
   行锁的劣势：开销大；加锁慢；会出现死锁
   行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强
   加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：
   共享锁：select * from tableName where ... + lock in share more
   排他锁：select * from tableName where ... + for update 
   InnoDB和MyISAM的最大不同点有两个：一，InnoDB支持事务(transaction)；二，默认采用行级锁。加锁可以保证事务的一致性，可谓是有人(锁)的地方，就有江湖(事务)；我们先简单了解一下事务知识。
   ```

   

os模块主要是和操作系统交互，sys模块主要是与解释器进行交互

字符串驻留：

- 节省内存
- 运行效率高

驻留条件：

- 字符串只在编译时进行驻留，而非运行时

- 字符串长度为0和1时，默认都采用了驻留机制

- 字符串>1时，且只含大小写字母、数字、下划线时，才会默认驻留

- 用乘法得到的字符串，有以下2种情况。

  a. 乘数为1时，字符串长度为1或者不包含其他字符，驻留

  b. 乘数>=2时，在仅含有字母数字下划线，且总长度<=20时，驻留

- 在使用sys.intern指定的字符串时，驻留