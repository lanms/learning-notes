### 1. 执行过程

- 每个线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。
- 协程，又称微线程，Coroutine。执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。实际上就是对函数调用流程的一种控制方式，让函数互相协作配合，这就是协程。

### 2. 调度方式

- 进程和线程完全由操作系统负责调度，程序自己不能决定什么时候执行，执行多长时间。
- 协程则是在程序中，自己负责调度，更加灵活，但复杂度较高。

### 3. 运行效率

- 进程是重量级别的程序，创建和销毁开销大。
- 线程是轻量级别的程序，相比进程下创建和销毁开销小，切换速度较快。
- 协程则是单线程的异步编程模型。和多线程比，线程数量越多，CPU就会花掉更多时间在切换中，而没有线程切换、保存上下文的开销的协程，相比下运行效率则更高。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，所以协程性能优势更加明显。

### 4. CPU利用

- 线程和协程由于CPython中全局解释器锁GIL的问题，只能使用到单核CPU的计算资源
- 进程则可以运行多个（数量与CPU核心数相同），充分利用多核CPU

> CPython解释器本身不是线程安全的，因此需要全局解释器锁GIL，一次只允许一个线程执行Python字节码。因此一个Python进程不能同时使用到多个CPU核心。
>  然而，标准库中所有执行阻塞型 IO 操作的函数，在等待结果返回时都会释放GIL。这意味着尽管有GIL，Python线程还是能在 IO 密集型任务中一展身手。 引用自《流畅的Python》

### 5. 最佳实践

- 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。
- 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。
- 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
   顺便一提，非常流行的一个爬虫框架Scrapy就是用到异步框架Twisted来进行任务的调度，这也是Scrapy框架高性能的原因之一。



### Linux进程/线程之间通讯

同一主机上的进程通信方式

* UNIX进程间通信方式: 包括管道(PIPE), 有名管道(FIFO), 和信号(Signal)

* System V进程通信方式：包括信号量(Semaphore), 消息队列(Message Queue), 和共享内存(Shared Memory)

网络主机间的进程通信方式

* RPC: Remote Procedure Call 远程过程调用

* Socket: 当前最流行的网络通信方式, 基于TCP/IP协议的通信方式.

**各自的特点如下:**

- **管道(PIPE)**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系(父子进程)的进程间使用。另外管道传送的是无格式的字节流，并且管道缓冲区的大小是有限的（管道缓冲区存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。
- **有名管道 (FIFO)**： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- **信号(Signal)**： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- **信号量(Semaphore)**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **消息队列(Message Queue)**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- **共享内存(Shared Memory )**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- **套接字(Socket)**： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。

 

**Linux系统中的线程间通信方式主要以下几种:**

\*  **锁机制**：包括互斥锁、条件变量、读写锁

   互斥锁提供了以排他方式防止数据结构被并发修改的方法。

   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

   条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

\*  **信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量

\*  **信号机制(Signal)**：类似进程间的信号处理





如何发现系统中的僵尸进程？
可以运行命令–>**ps -aux |grep -w ‘Z’** (这里的-w参数表示精确匹配)

#### 堆和栈

堆: FIFO   存储的是数组和对象（其实数组就是对象）,堆里的实体虽然不会被释放，但是会被当成垃圾

栈: FILO 栈内存首先是一片内存区域，存储的都是局部变量, 变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短 

#### 进程

程序运行在操作系统的一个实例，就称之为进程，进程需要相应的系统资源：内存，时间片，pid, 创建进程



#### Python进程通讯

Queue

```python
Queue.qsize()  当前消息队列的消息数量
Queue.empty() 是否为空
Queue.full()  是否已满
Queue.get()获取队列中的一条消息  其中默认block为True,阻塞等待获取消息
Queue.put()写入消息

```

#### 进程池

```python
from mutiprocessing import Pool
import os, time, random

def worker(msg):
    t_start = time.time()
    
    
```

#### 进程,线程,协程

- 进程: 一个运行的程序就是一个进程, 没有运行的代码叫做程序, 进程是系统资源分配的最小单位,进程拥有自己独立的内存空间,所有进程间数据不共享,开销大
- 线程: CPU调度执行的最小单位,也叫执行路径,不能独立存在,依赖进程存在,一个进程至少有一个线程,叫做主线程,而多个线程共享内存(数据共享,共享全局变量),从而极大地提高了程序呢的运行效率
- 协程: 用户态的轻量级线程,协程的调度完全由用户控制, 协成拥有自己的寄存器上下文和栈, 协程调度时, 将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先前保存的寄存器上下文和栈,直接操作栈则没有内核切换的开销,可以不加锁访问全局变量,所以上下文切换非常快.

#### 异步的使用场景:

1、 不涉及共享资源，获对共享资源只读，即非互斥操作

2、 没有时序上的严格关系

3、 不需要原子操作，或可以通过其他方式控制原子性

4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能

5、 不影响主线程逻辑





若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。

#### GIL锁 全局解释器锁

作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！

所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。

进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换

三者的关系：进程里有线程，线程里有协程



#### 简述浏览器通过WSGI请求动态资源的过程?

浏览器发送的请求被Nginx监听到，Nginx根据请求的URL的PATH或者后缀把请求静态资源的分发到静态资源的目录，别的请求根据配置好的转发到相应端口。 实现了WSGI的程序会监听某个端口，监听到Nginx转发过来的请求接收后(一般用socket的recv来接收HTTP的报文)以后把请求的报文封装成`environ`的字典对象，然后再提供一个`start_response`的方法。把这两个对象当成参数传入某个方法比如`wsgi_app(environ, start_response)`或者实现了`__call__(self, environ, start_response)`方法的某个实例。这个实例再调用`start_response`返回给实现了WSGI的中间件，再由中间件返回给Nginx。

### 描述用浏览器访问www.baidu.com的过程

域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户-->断开连接,4次挥手



cookie和session

具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持, cookie的内容主要包括：名字，值，过期时间，路径和域

session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。

session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。



TCP的2MSL

等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包

在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。
当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口