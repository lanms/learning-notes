### 1. 执行过程

- 每个线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。
- 协程，又称微线程，Coroutine。执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。实际上就是对函数调用流程的一种控制方式，让函数互相协作配合，这就是协程。

### 2. 调度方式

- 进程和线程完全由操作系统负责调度，程序自己不能决定什么时候执行，执行多长时间。
- 协程则是在程序中，自己负责调度，更加灵活，但复杂度较高。

### 3. 运行效率

- 进程是重量级别的程序，创建和销毁开销大。
- 线程是轻量级别的程序，相比进程下创建和销毁开销小，切换速度较快。
- 协程则是单线程的异步编程模型。和多线程比，线程数量越多，CPU就会花掉更多时间在切换中，而没有线程切换、保存上下文的开销的协程，相比下运行效率则更高。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，所以协程性能优势更加明显。

### 4. CPU利用

- 线程和协程由于CPython中全局解释器锁GIL的问题，只能使用到单核CPU的计算资源
- 进程则可以运行多个（数量与CPU核心数相同），充分利用多核CPU

> CPython解释器本身不是线程安全的，因此需要全局解释器锁GIL，一次只允许一个线程执行Python字节码。因此一个Python进程不能同时使用到多个CPU核心。
>  然而，标准库中所有执行阻塞型 IO 操作的函数，在等待结果返回时都会释放GIL。这意味着尽管有GIL，Python线程还是能在 IO 密集型任务中一展身手。 引用自《流畅的Python》

### 5. 最佳实践

- 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。
- 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。
- 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
   顺便一提，非常流行的一个爬虫框架Scrapy就是用到异步框架Twisted来进行任务的调度，这也是Scrapy框架高性能的原因之一。



### Linux进程/线程之间通讯

同一主机上的进程通信方式

* UNIX进程间通信方式: 包括管道(PIPE), 有名管道(FIFO), 和信号(Signal)

* System V进程通信方式：包括信号量(Semaphore), 消息队列(Message Queue), 和共享内存(Shared Memory)

网络主机间的进程通信方式

* RPC: Remote Procedure Call 远程过程调用

* Socket: 当前最流行的网络通信方式, 基于TCP/IP协议的通信方式.

**各自的特点如下:**

- **管道(PIPE)**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系(父子进程)的进程间使用。另外管道传送的是无格式的字节流，并且管道缓冲区的大小是有限的（管道缓冲区存在于内存中，在管道创建时，为缓冲区分配一个页面大小）。
- **有名管道 (FIFO)**： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- **信号(Signal)**： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- **信号量(Semaphore)**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- **消息队列(Message Queue)**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- **共享内存(Shared Memory )**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- **套接字(Socket)**： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。

 

**Linux系统中的线程间通信方式主要以下几种:**

\*  **锁机制**：包括互斥锁、条件变量、读写锁

   互斥锁提供了以排他方式防止数据结构被并发修改的方法。

   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。

   条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

\*  **信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量

\*  **信号机制(Signal)**：类似进程间的信号处理





如何发现系统中的僵尸进程？
可以运行命令–>**ps -aux |grep -w ‘Z’** (这里的-w参数表示精确匹配)