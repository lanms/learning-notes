### 1. 执行过程

- 每个线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在进程中，由进程提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。
- 协程，又称微线程，Coroutine。执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。实际上就是对函数调用流程的一种控制方式，让函数互相协作配合，这就是协程。

### 2. 调度方式

- 进程和线程完全由操作系统负责调度，程序自己不能决定什么时候执行，执行多长时间。
- 协程则是在程序中，自己负责调度，更加灵活，但复杂度较高。

### 3. 运行效率

- 进程是重量级别的程序，创建和销毁开销大。
- 线程是轻量级别的程序，相比进程下创建和销毁开销小，切换速度较快。
- 协程则是单线程的异步编程模型。和多线程比，线程数量越多，CPU就会花掉更多时间在切换中，而没有线程切换、保存上下文的开销的协程，相比下运行效率则更高。第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，所以协程性能优势更加明显。

### 4. CPU利用

- 线程和协程由于CPython中全局解释器锁GIL的问题，只能使用到单核CPU的计算资源
- 进程则可以运行多个（数量与CPU核心数相同），充分利用多核CPU

> CPython解释器本身不是线程安全的，因此需要全局解释器锁GIL，一次只允许一个线程执行Python字节码。因此一个Python进程不能同时使用到多个CPU核心。
>  然而，标准库中所有执行阻塞型 IO 操作的函数，在等待结果返回时都会释放GIL。这意味着尽管有GIL，Python线程还是能在 IO 密集型任务中一展身手。 引用自《流畅的Python》

### 5. 最佳实践

- 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。
- 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。
- 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
   顺便一提，非常流行的一个爬虫框架Scrapy就是用到异步框架Twisted来进行任务的调度，这也是Scrapy框架高性能的原因之一。